# Coding challenge solutions 

While doing coding challenges, I like to keep the solution and the original prompt so that I can refer back to them later.

* https://codingbat.com/java

## Interviewing / Coding Challenge Good Habits

Be familiar with data structures and when best to use them including:
* Hash Tables: Key, Value pair
* Linked Lists: Items that point to the next item in the list
* Stacks: LIFO - Last In First Out
* Queues: FIFO - First In First Out
* Trees: Node with children nodes
* Tries
* Graphs: Linked Nodes
* Vectors: Dynamic lists that resize when needed
* Heaps: Complete ordered binary tree 

Familiarize yourself with fundamental algorithms:
* Breadth-first search
* Depth-first search
* Merge sort

Ask questions about the problem even if it seems strait-forward. You want to make sure that what you are doing is the 
same as what the customer is expecting. Think about:
* Input - Expected values, data types, structure, null values, bad data, etc.
* Output - Expected values, data types, structure, object vs console

Think about the data
* Which algorithm might be best?
* What if the data is sorted?
* Would a different data structure work better?

Walk through the algorithm before starting coding. Use a white board/pseudocode/comments if you need to write down your
thought process. Check your thought process with your interviewer. 

Talk about your assumptions in the problem.
* Data structures needed to be implemented

Make it clear what direction you are going to go. Talk about what steps you will do next so that the other person
understands your direction.

Run through a test case to ensure that it will do what you think it will. Once that is done, you might want to consider 
going through an unhappy path to ensure that edge cases are taken care of. 

Algorithms are better than others in different circumstances. Think about what differences there are in the algorithms
and when to use them. Think about your solution and see if there is a better way (more efficient in time or space) to
accomplish the same goal. 
* Big(O) notation